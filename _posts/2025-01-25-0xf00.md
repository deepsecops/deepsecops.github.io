---
title: "0xf00's Shiftr"
description: >-
   In this reverse engineering challenge we will see how we can idenitfy the behavior of functions, resolving dependencies and communication between processes. 
author: deepsecops
date: 2025-01-17T12:00:00+0530
categories: [Reverse Engineering Challanges, '0xf00']
tags: [crackme]
toc: true
---


Link to the Challenge: [**https://crackmes.one/crackme/675ad67560fa67152406b81c**](https://crackmes.one/crackme/675ad67560fa67152406b81c)

My Linkedin Profile: [**https://www.linkedin.com/in/deepak-bhardwaj-aa8543143/**](https://www.linkedin.com/in/deepak-bhardwaj-aa8543143/)

My crackme's profile: [**https://crackmes.one/user/anon786**](https://crackmes.one/user/anon786)


This challenge was also fine, we need to make sure we understand what the underlying function does and why exactly it is getting used, if we observe carefully we would get to know the inner workings of it by analyzing the decompiled binary code and looking into the flow of the code, so lets start analyzing the functions we will use ghidra for getting the decompiled version of the functions:

Observe that its an ELF binary, with the symbols as stripped. 
img-1


So, when we look at the decompiled code, we would observed that we are in entry point of the binary, where the helper function "_libc_start_main" invokes the "main" function, in our case the main function is "FUN_00101d9b". 

img-2

### # Analysis of "FUN_00101d9b":

Lets analyze the working of the function "FUN_00101d9b":

```c
undefined8 FUN_00101d9b(void)
{
  int iVar1;
  undefined4 uVar2;
  int iVar3;
  char *pcVar4;
  size_t sVar5;
  size_t sVar6;
  undefined8 uVar7;
  long in_FS_OFFSET;
  int local_d0;
  int local_cc;
  char local_a8 [32];
  char local_88 [104];
  long local_20;
  
  local_20 = *(long *)(in_FS_OFFSET + 0x28);
  FUN_00101480();
  iVar1 = FUN_00101be6();
  if (iVar1 == 0) {
    FUN_00101b5c(local_a8,8);
    uVar2 = FUN_00101d51(local_a8);
    FUN_00101976(local_a8,8,uVar2);
    FUN_00101480();
    local_cc = 0;
    while (local_cc < 3) {
      printf("$: ");
      pcVar4 = fgets(local_88,100,stdin);
      if (pcVar4 == (char *)0x0) {
        uVar7 = 1;
        goto LAB_001020f1;
      }
      sVar5 = strcspn(local_88,"\n");
      local_88[sVar5] = '\0';
      sVar5 = strlen(local_88);
      sVar6 = strlen(local_a8);
      if (sVar6 < sVar5) {
        fwrite("Too long! Try again.\n",1,0x15,stderr);
        FUN_00101469();
      }
      else {
        iVar1 = FUN_00101c7c(local_88,local_a8);
        if (iVar1 != 0) {
          puts("Nicely done! ");
          FUN_00101d37();
          uVar7 = 0;
          goto LAB_001020f1;
        }
        local_cc = local_cc + 1;
        printf("Wrong! %d left.\n",(ulong)(3 - local_cc));
        sleep(1);
      }
    }
    uVar7 = 1;
  }
  else {
    FUN_00101b5c(local_a8,8);
    uVar2 = FUN_00101d51(local_a8);
    FUN_00101536(local_a8,8,uVar2);
    local_d0 = 0;
    while (local_d0 < 3) {
      printf("$: ");
      pcVar4 = fgets(local_88,100,stdin);
      if (pcVar4 == (char *)0x0) {
        uVar7 = 1;
        goto LAB_001020f1;
      }
      sVar5 = strcspn(local_88,"\n");
      local_88[sVar5] = '\0';
      sVar5 = strlen(local_88);
      sVar6 = strlen(local_a8);
      if (sVar6 < sVar5) {
        fwrite("Too long! No buffer overflow here.\n",1,0x23,stderr);
        FUN_00101469();
      }
      else {
        iVar1 = FUN_00101d51(local_88);
        iVar3 = FUN_00101d51(local_a8);
        if (iVar1 == iVar3) {
          sleep(0x32);
          puts("is it real? Nah");
          uVar7 = 0;
          goto LAB_001020f1;
        }
        local_d0 = local_d0 + 1;
        printf("Wrong! %d left.\n",(ulong)(3 - local_d0));
        sleep(1);
      }
    }
    uVar7 = 1;
  }
LAB_001020f1:
  if (local_20 != *(long *)(in_FS_OFFSET + 0x28)) {
                    /* WARNING: Subroutine does not return */
    __stack_chk_fail();
  }
  return uVar7;
}
```

























